<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StorageClass Ranking</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f5f5; color: #333; }
    .header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white; padding: 2rem; }
    .header h1 { font-size: 1.8rem; margin-bottom: 0.3rem; }
    .header .meta { color: #aaa; font-size: 0.85rem; }
    .methodology { background: white; border-radius: 8px; padding: 1.5rem 2rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 1.5rem; line-height: 1.6; font-size: 0.92rem; color: #444; }
    .methodology h2 { font-size: 1.15rem; color: #1a1a2e; margin: 0 0 0.8rem 0; padding: 0; border: none; }
    .methodology p { margin: 0 0 0.7rem 0; }
    .methodology p:last-child { margin-bottom: 0; }
    .methodology .detail-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.3rem 2rem; margin: 0.5rem 0; font-size: 0.88rem; }
    .methodology .detail-grid dt { color: #777; }
    .methodology .detail-grid dd { font-weight: 500; margin: 0; }
    .container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
    .section { margin-bottom: 2rem; }
    .section h2 { font-size: 1.3rem; color: #1a1a2e; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0; }
    .card { background: white; border-radius: 8px; padding: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 1rem; }
    table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
    th, td { padding: 0.6rem 0.8rem; text-align: left; border-bottom: 1px solid #eee; }
    th { background: #f8f9fa; font-weight: 600; position: sticky; top: 0; }
    .num { text-align: right; }
    .rank-1 td { background: #fff9e6; }
    .rank-2 td { background: #f5f5f5; }
    .rank-3 td { background: #fdf0ed; }
    .score-bar { display: inline-block; height: 20px; border-radius: 3px; vertical-align: middle; min-width: 2px; }
    .chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 1rem; }
    .collapsible { cursor: pointer; user-select: none; }
    .collapsible::after { content: ' [+]'; font-size: 0.8rem; color: #999; }
    .collapsible.open::after { content: ' [-]'; }
    .collapse-content { display: none; }
    .collapse-content.open { display: block; }
    .weight-badge { display: inline-block; background: #e0e0e0; color: #555; font-size: 0.7rem; padding: 0.15rem 0.4rem; border-radius: 3px; margin-left: 0.5rem; }
  </style>
</head>
<body>
  <div class="header">
    <h1>StorageClass Performance Ranking</h1>
    <div class="meta" id="meta"></div>
  </div>
  <div class="container">
    <div class="methodology" id="methodology"></div>
  </div>
  <div class="container">
    <div class="section">
      <h2 class="collapsible open" onclick="toggleCollapse(this)">About the StorageClasses</h2>
      <div class="collapse-content open">
        <div class="card"><table id="poolInfoTable"></table></div>
      </div>
    </div>
    <div class="section">
      <h2 class="collapsible open" onclick="toggleCollapse(this)">About the Workloads</h2>
      <div class="collapse-content open">
        <div class="card"><table id="workloadInfoTable"></table></div>
      </div>
    </div>
    <div class="section">
      <h2>Overall Composite Ranking</h2>
      <div class="card">
        <table id="compositeTable"></table>
      </div>
      <div class="card"><canvas id="compositeChart" height="80"></canvas></div>
    </div>
    <div class="section">
      <h2>Per-Workload Rankings</h2>
      <div class="chart-grid" id="workloadCharts"></div>
    </div>
    <div class="section">
      <h2>Latency Ranking (Random 4k)</h2>
      <div class="card">
        <table id="latencyTable"></table>
      </div>
    </div>
    <div class="section">
      <h2 class="collapsible" onclick="toggleCollapse(this)">Raw Data</h2>
      <div class="collapse-content">
        <div class="card"><table id="rawTable"></table></div>
      </div>
    </div>
  </div>
  <script>
    const DATA = {"pools": ["bench-pool", "cephfs-rep3", "ec-2-1", "ibmc-vpc-file-1000-iops", "ibmc-vpc-file-3000-iops", "ibmc-vpc-file-500-iops", "rep2", "rep3", "rep3-enc", "rep3-virt"], "workload_rankings": [{"id": "random_iops", "title": "Random 4k IOPS", "higher_better": true, "ranking": [{"pool": "rep2", "value": 133789.0, "total_iops": 133789, "read_iops": 132120, "write_iops": 1669}, {"pool": "rep3", "value": 126840.0, "total_iops": 126840, "read_iops": 125390, "write_iops": 1450}, {"pool": "rep3-virt", "value": 126586.0, "total_iops": 126586, "read_iops": 125170, "write_iops": 1416}, {"pool": "rep3-enc", "value": 122448.0, "total_iops": 122448, "read_iops": 121058, "write_iops": 1390}, {"pool": "cephfs-rep3", "value": 107018.0, "total_iops": 107018, "read_iops": 98136, "write_iops": 8882}, {"pool": "bench-pool", "value": 95095.0, "total_iops": 95095, "read_iops": 67951, "write_iops": 27144}, {"pool": "ec-2-1", "value": 61210.0, "total_iops": 61210, "read_iops": 60387, "write_iops": 823}, {"pool": "ibmc-vpc-file-3000-iops", "value": 5761.0, "total_iops": 5761, "read_iops": 2997, "write_iops": 2764}, {"pool": "ibmc-vpc-file-1000-iops", "value": 3955.0, "total_iops": 3955, "read_iops": 1994, "write_iops": 1961}, {"pool": "ibmc-vpc-file-500-iops", "value": 1977.0, "total_iops": 1977, "read_iops": 994, "write_iops": 983}]}, {"id": "seq_bw", "title": "Sequential 1M Throughput", "higher_better": true, "ranking": [{"pool": "rep2", "value": 12015.3, "total_mib": 12015.3, "read_mib": 11537.7, "write_mib": 477.6}, {"pool": "rep3-virt", "value": 11595.45, "total_mib": 11595.4, "read_mib": 11172.1, "write_mib": 423.4}, {"pool": "rep3", "value": 11427.19, "total_mib": 11427.2, "read_mib": 11002.0, "write_mib": 425.2}, {"pool": "rep3-enc", "value": 10855.03, "total_mib": 10855.0, "read_mib": 10225.4, "write_mib": 629.7}, {"pool": "cephfs-rep3", "value": 9823.7, "total_mib": 9823.7, "read_mib": 7852.6, "write_mib": 1971.1}, {"pool": "bench-pool", "value": 4099.74, "total_mib": 4099.7, "read_mib": 2049.8, "write_mib": 2049.9}, {"pool": "ec-2-1", "value": 1200.01, "total_mib": 1200.0, "read_mib": 844.9, "write_mib": 355.1}, {"pool": "ibmc-vpc-file-3000-iops", "value": 750.34, "total_mib": 750.3, "read_mib": 375.4, "write_mib": 375.0}, {"pool": "ibmc-vpc-file-1000-iops", "value": 252.87, "total_mib": 252.9, "read_mib": 126.9, "write_mib": 126.0}, {"pool": "ibmc-vpc-file-500-iops", "value": 126.79, "total_mib": 126.8, "read_mib": 64.4, "write_mib": 62.4}]}, {"id": "mixed_iops", "title": "Mixed 70/30 4k IOPS", "higher_better": true, "ranking": [{"pool": "rep2", "value": 103316.0, "total_iops": 103316, "read_iops": 72280, "write_iops": 31036}, {"pool": "rep3", "value": 93705.0, "total_iops": 93705, "read_iops": 65549, "write_iops": 28156}, {"pool": "rep3-virt", "value": 93027.0, "total_iops": 93027, "read_iops": 65073, "write_iops": 27954}, {"pool": "rep3-enc", "value": 90347.0, "total_iops": 90347, "read_iops": 63192, "write_iops": 27155}, {"pool": "cephfs-rep3", "value": 78377.0, "total_iops": 78377, "read_iops": 54819, "write_iops": 23558}, {"pool": "bench-pool", "value": 60053.0, "total_iops": 60053, "read_iops": 41989, "write_iops": 18064}, {"pool": "ibmc-vpc-file-3000-iops", "value": 5993.0, "total_iops": 5993, "read_iops": 4191, "write_iops": 1802}, {"pool": "ec-2-1", "value": 4016.0, "total_iops": 4016, "read_iops": 2811, "write_iops": 1205}, {"pool": "ibmc-vpc-file-1000-iops", "value": 1994.0, "total_iops": 1994, "read_iops": 1394, "write_iops": 600}, {"pool": "ibmc-vpc-file-500-iops", "value": 992.0, "total_iops": 992, "read_iops": 690, "write_iops": 302}]}], "latency_ranking": [{"pool": "bench-pool", "read_lat_avg": 1.907, "write_lat_avg": 4.745, "read_p99": 7.94, "write_p99": 64.352, "avg_p99": 36.146}, {"pool": "ibmc-vpc-file-3000-iops", "read_lat_avg": 21.34, "write_lat_avg": 23.135, "read_p99": 30.8, "write_p99": 60.03, "avg_p99": 45.415}, {"pool": "rep2", "read_lat_avg": 1.005, "write_lat_avg": 77.987, "read_p99": 25.165, "write_p99": 128.185, "avg_p99": 76.675}, {"pool": "ibmc-vpc-file-1000-iops", "read_lat_avg": 64.085, "write_lat_avg": 65.162, "read_p99": 84.407, "write_p99": 75.495, "avg_p99": 79.951}, {"pool": "rep3", "read_lat_avg": 1.052, "write_lat_avg": 88.09, "read_p99": 24.64, "write_p99": 144.7, "avg_p99": 84.67}, {"pool": "rep3-virt", "read_lat_avg": 1.058, "write_lat_avg": 90.208, "read_p99": 24.64, "write_p99": 150.993, "avg_p99": 87.816}, {"pool": "rep3-enc", "read_lat_avg": 1.095, "write_lat_avg": 91.985, "read_p99": 25.295, "write_p99": 150.99, "avg_p99": 88.143}, {"pool": "ibmc-vpc-file-500-iops", "read_lat_avg": 128.368, "write_lat_avg": 129.715, "read_p99": 175.11, "write_p99": 174.062, "avg_p99": 174.586}, {"pool": "cephfs-rep3", "read_lat_avg": 1.308, "write_lat_avg": 14.425, "read_p99": 3.078, "write_p99": 425.717, "avg_p99": 214.397}, {"pool": "ec-2-1", "read_lat_avg": 5.518, "write_lat_avg": 172.062, "read_p99": 12.975, "write_p99": 450.885, "avg_p99": 231.93}], "composite": [{"pool": "rep2", "score": 94.7, "breakdown": {"random_iops": 100.0, "seq_bw": 100.0, "mixed_iops": 100.0, "p99_lat": 47.1}}, {"pool": "rep3-virt", "score": 88.7, "breakdown": {"random_iops": 94.6, "seq_bw": 96.5, "mixed_iops": 90.0, "p99_lat": 39.0}}, {"pool": "rep3", "score": 88.6, "breakdown": {"random_iops": 94.8, "seq_bw": 95.1, "mixed_iops": 90.7, "p99_lat": 40.5}}, {"pool": "rep3-enc", "score": 84.9, "breakdown": {"random_iops": 91.5, "seq_bw": 90.3, "mixed_iops": 87.4, "p99_lat": 37.5}}, {"pool": "cephfs-rep3", "score": 73.1, "breakdown": {"random_iops": 80.0, "seq_bw": 81.8, "mixed_iops": 75.9, "p99_lat": 13.5}}, {"pool": "bench-pool", "score": 57.4, "breakdown": {"random_iops": 71.1, "seq_bw": 34.1, "mixed_iops": 58.1, "p99_lat": 71.1}}, {"pool": "ec-2-1", "score": 22.8, "breakdown": {"random_iops": 45.8, "seq_bw": 10.0, "mixed_iops": 3.9, "p99_lat": 7.1}}, {"pool": "ibmc-vpc-file-3000-iops", "score": 5.1, "breakdown": {"random_iops": 4.3, "seq_bw": 6.2, "mixed_iops": 5.8, "p99_lat": 3.4}}, {"pool": "ibmc-vpc-file-1000-iops", "score": 2.3, "breakdown": {"random_iops": 3.0, "seq_bw": 2.1, "mixed_iops": 1.9, "p99_lat": 1.3}}, {"pool": "ibmc-vpc-file-500-iops", "score": 1.2, "breakdown": {"random_iops": 1.5, "seq_bw": 1.1, "mixed_iops": 1.0, "p99_lat": 0.3}}], "weights": {"random_iops": 0.4, "seq_bw": 0.3, "mixed_iops": 0.2, "p99_lat": 0.1}, "pool_info": [{"name": "bench-pool", "type": "IBM Cloud Pool CSI", "description": "Pre-provisioned NFS file share pool via Pool CSI driver (4000Gi at 40000 IOPS, dp2 profile).", "vsan": "N/A (managed service)", "overhead": "1x (managed)"}, {"name": "cephfs-rep3", "type": "ODF CephFS Replicated 3-way", "description": "Ceph Filesystem with 3x replicated data pool. Uses file-on-filesystem indirection in KubeVirt.", "vsan": "vSAN File Service (RAID-1, FTT=2)", "overhead": "3x (data) + 3x (metadata)"}, {"name": "ec-2-1", "type": "ODF Erasure Coded 2+1", "description": "Ceph RBD with erasure coding (2 data + 1 coding chunks). Better space efficiency than replication.", "vsan": "RAID-5, FTT=1", "overhead": "1.5x"}, {"name": "ibmc-vpc-file-1000-iops", "type": "IBM Cloud File CSI", "description": "NFS-based file storage via VPC File CSI driver. 1000 IOPS tier.", "vsan": "N/A (managed service)", "overhead": "1x (managed)"}, {"name": "ibmc-vpc-file-3000-iops", "type": "IBM Cloud File CSI", "description": "NFS-based file storage via VPC File CSI driver. 3000 IOPS tier.", "vsan": "N/A (managed service)", "overhead": "1x (managed)"}, {"name": "ibmc-vpc-file-500-iops", "type": "IBM Cloud File CSI", "description": "NFS-based file storage via VPC File CSI driver. 500 IOPS tier.", "vsan": "N/A (managed service)", "overhead": "1x (managed)"}, {"name": "rep2", "type": "ODF Replicated 2-way", "description": "Ceph RBD block storage with 2x replication across failure domains.", "vsan": "RAID-1, FTT=1", "overhead": "2x"}, {"name": "rep3", "type": "ODF Replicated 3-way", "description": "Ceph RBD block storage with 3x replication across failure domains.", "vsan": "RAID-1, FTT=2", "overhead": "3x"}, {"name": "rep3-enc", "type": "ODF Replicated 3-way", "description": "Ceph RBD block storage with 3x replication across failure domains. (encrypted at-rest via LUKS)", "vsan": "RAID-1, FTT=2", "overhead": "3x"}, {"name": "rep3-virt", "type": "ODF Replicated 3-way", "description": "Ceph RBD block storage with 3x replication across failure domains. (VM-optimized SC with write-back caching features)", "vsan": "RAID-1, FTT=2", "overhead": "3x"}], "test_config": {"vm_size": "medium", "pvc_size": "150Gi", "concurrency": "1"}};
    const RUN_ID = "perf-20260225-102034";
    const COLORS = ['#e63946','#457b9d','#2a9d8f','#e9c46a','#f4a261','#264653',
                    '#a8dadc','#d62828','#023e8a','#780000','#6a4c93','#1982c4',
                    '#8ac926','#ff595e','#ffca3a'];
    // Header meta (run ID only)
    document.getElementById('meta').innerHTML = 'Run: ' + RUN_ID;

    // Methodology write-up
    (function() {
      const cfg = DATA.test_config || {};
      const pools = (DATA.pool_info || []).length;
      let html = '<h2>How This Report Works</h2>';
      html += '<p>This report ranks <strong>' + pools + ' StorageClasses</strong> by running the same set of I/O benchmarks against each one under identical conditions, then combining the results into a single composite score. The goal is to answer: <em>which StorageClass gives the best overall performance for VM workloads on this cluster?</em></p>';
      html += '<p><strong>What was tested:</strong> Each StorageClass was provisioned as a ' + (cfg.pvc_size || '150Gi') + ' data disk attached to a ' + (cfg.vm_size || 'small') + ' VM (2 vCPU, 4 GiB RAM). Three fio benchmarks were run on each disk:</p>';
      html += '<ul style="margin:0.3rem 0 0.7rem 1.5rem">';
      html += '<li><strong>Random 4k IOPS</strong> — measures how many small I/O operations per second the storage can handle (IOPS). This is what matters for databases and general VM activity.</li>';
      html += '<li><strong>Sequential 1M Throughput</strong> — measures raw data transfer speed (throughput in MiB/s). This is what matters for backups, large file copies, and data pipelines.</li>';
      html += '<li><strong>Mixed 70/30 4k IOPS</strong> — a realistic blend of 70% reads and 30% writes that simulates everyday application workloads like web servers and file shares.</li>';
      html += '</ul>';
      html += '<p><strong>How scoring works:</strong> Each StorageClass is scored 0-100 on each workload (100 = best performer). These are combined into a weighted composite score:</p>';
      html += '<dl class="detail-grid">';
      html += '<dt>Random 4k IOPS</dt><dd>40% weight — most impactful for general VM performance</dd>';
      html += '<dt>Sequential 1M throughput</dt><dd>30% weight — important for data-heavy workloads</dd>';
      html += '<dt>Mixed 70/30 IOPS</dt><dd>20% weight — reflects real-world application patterns</dd>';
      html += '<dt>p99 latency (lower is better)</dt><dd>10% weight — tail latency from random 4k I/O, weighted by throughput so pools doing fewer IOPS don\'t get an unfair advantage</dd>';
      html += '</dl>';
      html += '<p style="margin-top:0.5rem"><strong>Test parameters:</strong> Each benchmark ran for 60 seconds with a 10-second warmup, using direct I/O (O_DIRECT, bypassing OS cache), I/O depth of 32, and 4 parallel worker threads per job. All tests used a single VM with concurrency of ' + (cfg.concurrency || '1') + '.</p>';
      document.getElementById('methodology').innerHTML = html;
    })();

    // Pool info table
    (function() {
      const info = DATA.pool_info || [];
      if (!info.length) return;
      let html = '<thead><tr><th>StorageClass</th><th>Type</th><th>vSAN Equivalent</th><th>Storage Overhead</th><th>Description</th></tr></thead><tbody>';
      info.forEach(p => {
        html += '<tr><td><strong>' + p.name + '</strong></td><td>' + p.type + '</td><td>' + p.vsan + '</td><td>' + p.overhead + '</td><td>' + p.description + '</td></tr>';
      });
      html += '</tbody>';
      document.getElementById('poolInfoTable').innerHTML = html;
    })();

    // Workload info table
    (function() {
      const workloads = [
        { name: 'Random 4k IOPS', bs: '4k', desc: 'Small-block random I/O — measures IOPS capacity. Typical of databases and VM disk activity.' },
        { name: 'Sequential 1M Throughput', bs: '1M', desc: 'Large-block sequential I/O — measures bandwidth/throughput. Typical of backups and bulk data transfer.' },
        { name: 'Mixed 70/30 4k IOPS', bs: '4k', desc: '70% reads / 30% writes — simulates typical application workloads like web apps and file servers.' },
        { name: 'p99 Tail Latency', bs: '4k', desc: 'Derived from the Random 4k test. The 99th percentile I/O response time — 99% of operations complete faster than this. Lower is better. Measures worst-case storage responsiveness.' },
      ];
      let html = '<thead><tr><th>Workload</th><th>Block Size</th><th>What It Measures</th></tr></thead><tbody>';
      workloads.forEach(w => {
        html += '<tr><td><strong>' + w.name + '</strong></td><td>' + w.bs + '</td><td>' + w.desc + '</td></tr>';
      });
      html += '</tbody>';
      document.getElementById('workloadInfoTable').innerHTML = html;
    })();

    // Composite table
    (function() {
      const comp = DATA.composite;
      let html = '<thead><tr><th>Rank</th><th>StorageClass</th><th class="num">Composite Score</th>';
      html += '<th class="num">Random 4k IOPS<span class="weight-badge">40%</span></th>';
      html += '<th class="num">Sequential 1M BW<span class="weight-badge">30%</span></th>';
      html += '<th class="num">Mixed 70/30 IOPS<span class="weight-badge">20%</span></th>';
      html += '<th class="num">p99 Latency<span class="weight-badge">10%</span></th>';
      html += '</tr></thead><tbody>';
      comp.forEach((c, i) => {
        const cls = i < 3 ? ' class="rank-' + (i+1) + '"' : '';
        html += '<tr' + cls + '><td>#' + (i+1) + '</td>';
        html += '<td><strong>' + c.pool + '</strong></td>';
        html += '<td class="num">' + c.score + '</td>';
        const dims = ['random_iops', 'seq_bw', 'mixed_iops', 'p99_lat'];
        dims.forEach(d => {
          const v = c.breakdown[d] !== undefined ? c.breakdown[d] : '-';
          html += '<td class="num">' + v + '</td>';
        });
        html += '</tr>';
      });
      html += '</tbody>';
      document.getElementById('compositeTable').innerHTML = html;
    })();

    // Composite bar chart
    (function() {
      const comp = DATA.composite;
      new Chart(document.getElementById('compositeChart'), {
        type: 'bar',
        data: {
          labels: comp.map(c => c.pool),
          datasets: [{
            label: 'Composite Score',
            data: comp.map(c => c.score),
            backgroundColor: comp.map((_, i) => COLORS[i % COLORS.length]),
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          plugins: { legend: { display: false } },
          scales: {
            x: { beginAtZero: true, max: 105, title: { display: true, text: 'Score (best = 100)' } },
          }
        }
      });
    })();

    // Per-workload charts and tables
    (function() {
      const container = document.getElementById('workloadCharts');
      DATA.workload_rankings.forEach((wl, wi) => {
        const card = document.createElement('div');
        card.className = 'card';
        const unit = wl.id === 'seq_bw' ? 'MiB/s' : 'IOPS';
        const valKey = wl.id === 'seq_bw' ? 'total_mib' : 'total_iops';
        const readKey = wl.id === 'seq_bw' ? 'read_mib' : 'read_iops';
        const writeKey = wl.id === 'seq_bw' ? 'write_mib' : 'write_iops';

        let html = '<h3 style="margin-bottom:0.5rem">' + wl.title + '</h3>';
        html += '<table><thead><tr><th>Rank</th><th>StorageClass</th><th class="num">Total ' + unit + '</th>';
        html += '<th class="num">Read</th><th class="num">Write</th></tr></thead><tbody>';
        wl.ranking.forEach((r, i) => {
          const cls = i < 3 ? ' class="rank-' + (i+1) + '"' : '';
          html += '<tr' + cls + '><td>#' + (i+1) + '</td>';
          html += '<td>' + r.pool + '</td>';
          html += '<td class="num"><strong>' + (r[valKey] !== undefined ? r[valKey].toLocaleString() : r.value) + '</strong></td>';
          html += '<td class="num">' + (r[readKey] !== undefined ? r[readKey].toLocaleString() : '-') + '</td>';
          html += '<td class="num">' + (r[writeKey] !== undefined ? r[writeKey].toLocaleString() : '-') + '</td>';
          html += '</tr>';
        });
        html += '</tbody></table>';

        const canvasId = 'wlChart' + wi;
        html += '<canvas id="' + canvasId + '" height="60" style="margin-top:0.5rem"></canvas>';
        card.innerHTML = html;
        container.appendChild(card);

        new Chart(document.getElementById(canvasId), {
          type: 'bar',
          data: {
            labels: wl.ranking.map(r => r.pool),
            datasets: [
              { label: 'Read', data: wl.ranking.map(r => r[readKey] || 0), backgroundColor: '#457b9d' },
              { label: 'Write', data: wl.ranking.map(r => r[writeKey] || 0), backgroundColor: '#e63946' },
            ]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            plugins: { legend: { position: 'top' } },
            scales: { x: { beginAtZero: true, stacked: true, title: { display: true, text: unit } }, y: { stacked: true } }
          }
        });
      });
    })();

    // Latency table
    (function() {
      const lat = DATA.latency_ranking;
      let html = '<thead><tr><th>Rank</th><th>StorageClass</th><th class="num">Read Avg (ms)</th>';
      html += '<th class="num">Write Avg (ms)</th><th class="num">Read p99 (ms)</th><th class="num">Write p99 (ms)</th>';
      html += '<th class="num">Avg p99 (ms)</th></tr></thead><tbody>';
      lat.forEach((r, i) => {
        const cls = i < 3 ? ' class="rank-' + (i+1) + '"' : '';
        html += '<tr' + cls + '><td>#' + (i+1) + '</td>';
        html += '<td>' + r.pool + '</td>';
        html += '<td class="num">' + r.read_lat_avg + '</td><td class="num">' + r.write_lat_avg + '</td>';
        html += '<td class="num">' + r.read_p99 + '</td><td class="num">' + r.write_p99 + '</td>';
        html += '<td class="num"><strong>' + r.avg_p99 + '</strong></td></tr>';
      });
      html += '</tbody>';
      document.getElementById('latencyTable').innerHTML = html;
    })();

    // Raw data table (from composite + workload data)
    (function() {
      const comp = DATA.composite;
      const wls = DATA.workload_rankings;
      let html = '<thead><tr><th>StorageClass</th><th class="num">Composite</th>';
      wls.forEach(wl => { html += '<th class="num">' + wl.title + '</th>'; });
      html += '<th class="num">Avg p99 (ms)</th></tr></thead><tbody>';
      comp.forEach(c => {
        html += '<tr><td>' + c.pool + '</td><td class="num">' + c.score + '</td>';
        wls.forEach(wl => {
          const entry = wl.ranking.find(r => r.pool === c.pool);
          html += '<td class="num">' + (entry ? entry.value : '-') + '</td>';
        });
        const latEntry = DATA.latency_ranking.find(r => r.pool === c.pool);
        html += '<td class="num">' + (latEntry ? latEntry.avg_p99 : '-') + '</td>';
        html += '</tr>';
      });
      html += '</tbody>';
      document.getElementById('rawTable').innerHTML = html;
    })();

    function toggleCollapse(el) {
      el.classList.toggle('open');
      el.nextElementSibling.classList.toggle('open');
    }
  </script>
</body>
</html>
